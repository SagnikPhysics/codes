# -*- coding: utf-8 -*-
"""exponential fitting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u8nE1A4ViAOxPyLjirR5CYPDVrWgM0sD
"""

import numpy as np
import matplotlib.pyplot as pl
from scipy.optimize import curve_fit

x = np.linspace(1.0,10.0,30)
y = 5.0*np.exp(-x)

fit,_ = curve_fit(lambda x,a,b: a*np.exp(b*x),x,y)
print(fit[0],fit[1])

def matrix_inverse(matrix):
  def transposeMatrix(matrix):
    return map(list,zip(*matrix))
  def getMatrixMinor(matrix,i,j):
    return [row[:j] + row[j+1:] for row in (matrix[:i]+matrix[i+1:])]

  def deternminant(matrix):
    #base case for 2x2 matrix
    if len(matrix) == 2:
      return matrix[0][0]*matrix[1][1]-matrix[0][1]*matrix[1][0]
    det = 0
    for c in range(len(matrix)):
      det += ((-1)**c)*matrix[0][c]*deternminant(getMatrixMinor(matrix,0,c))
    return det

  det = deternminant(matrix)
  # special case for 2x2 matrix:
  if len(matrix) == 2:
    return [[matrix[1][1]/det, -1*matrix[0][1]/det],
            [-1*matrix[1][0]/det, matrix[0][0]/det]]

  # find matrix of cofactors
  cofactors = []
  for r in range(len(matrix)):
    cofactorRow = []
    for c in range(len(matrix)):
      minor = getMatrixMinor(matrix,r,c)
      cofactorRow.append(((-1)**(r+c)) * deternminant(minor))
    cofactors.append(cofactorRow)
  cofactors = transposeMatrix(cofactors)
  for r in range(len(cofactors)):
    for c in range(len(cofactors)):
      cofactors[r][c] = cofactors[r][c]/det
  return cofactors

A = []
for j in range(2):
  temp = []
  for i in range(2):
    temp.append(sum(x**(j+i)))
  A.append(temp)

A = np.reshape(A,(2,2))
invA = np.reshape(matrix_inverse(A),(2,2))

C = []
for i in range(2):
  C.append(sum(np.log(y)*x**i))
C = np.array(C)

fitlin = np.dot(invA,C)
print(np.exp(fitlin[0]),fitlin[1])

pl.plot(x,y,'ko',zorder=0)
pl.plot(x,fit[0]*np.exp(fit[1]*x),'r--',zorder=1)
pl.plot(x,np.exp(fitlin[0]+fitlin[1]*x),'g--',zorder=1)
pl.show()